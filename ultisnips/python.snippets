global !p
from ultisnips_helpers import *
endglobal

snippet shebang "shebang" b
#!/usr/bin/env python
endsnippet

snippet encoding "python 2 encoding" b
# encoding: utf-8
endsnippet

snippet __all "__all__" b
__all__ = [$1]
endsnippet

snippet i "import" b
import $0
endsnippet

snippet f "from" b
from $0
endsnippet

snippet [ "[...]" i
[$1]
endsnippet

snippet ( "(...)" i
($1)
endsnippet

snippet < "<...>" i
<$1>
endsnippet

snippet " "double quote" i
"$1"
endsnippet

snippet ' "single quote" i
'$1'
endsnippet

snippet in "import numpy" b
import numpy as np
endsnippet

snippet inp "import numpy, pandas" b
import numpy as np
import pandas as pd
endsnippet

snippet inpm "import numpy, pandas, matplotlib" b
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
endsnippet

snippet fsql "from sqlalchemy import ..." b
from sqlalchemy import $0
endsnippet

snippet fsqlengine "from sqlalchemy import create_engine" b
from sqlalchemy import create_engine, text
endsnippet

snippet fsqlmeta "from sqlalchemy import MetaData" b
from sqlalchemy import MetaData, Table
endsnippet

snippet glb "globals()[...] = ..." b
globals()['$1'] = $1
endsnippet

snippet exit "sys.exit()" b
import sys; sys.exit()
endsnippet

snippet pr "print('...', ....)" b
print("$1:", $1)
endsnippet

snippet pdb "pdb.set_trace()" b
import pdb; pdb.set_trace()
endsnippet

snippet ipdb "ipdb.set_trace()" b
import ipdb; ipdb.set_trace()
endsnippet

snippet s. "self." w
self.$0
endsnippet

snippet s_ "self._" w
self._$0
endsnippet

snippet s.. "self.xxx = xxx" w
self.$1 = $1
endsnippet

snippet s__ "self._xxx = xxx" w
self._$1 = $1
endsnippet

snippet py3 "python 3 file template" b
#!/usr/bin/env python3
"""$1
"""
$2


$0

endsnippet

snippet py "python file template" b
#!/usr/bin/env python
"""$1
"""
$2


$0

endsnippet

snippet py2 "python 2 file template" b
#!/usr/bin/env python2
# encoding: utf-8
"""$1
"""
from __future__ import print_function, division, unicode_literals
from io import open
$2


$0

endsnippet

snippet py2-future "python 2 __future__ import" b
from __future__ import print_function, division, unicode_literals
endsnippet

snippet py2-io "python 2 io import" b
from io import open
endsnippet

snippet __author "author declaration" w
__author__ = ("${1:Zhao Jiarong} ${2:<kawing.chiu.sysu@gmail.com>}")
endsnippet

snippet ifm "if main" bw
def main():
	${0:pass}

if __name__ == '__main__':
	main()
endsnippet

snippet ifma "if main with arg parsing" bw
def _parse_args():
	from argparse import ArgumentParser
	parser = ArgumentParser(description="$1")$2
	args = parser.parse_args()
	return args

def main():
	args = _parse_args()$0

if __name__ == '__main__':
	main()
endsnippet

snippet doc "docstring" w
"""$1`!p
indent = get_indent(snip, shift=0)
prefix = '\n\n' + indent
add_str_if(snip, t[2], prefix)
`$2`!p
if not t[2]:
    suffix = '"""' 
else:
    suffix = '\n' + indent + '"""'
add_str(snip, suffix)
refresh(snip)
`
endsnippet

snippet def "function definition" b
def $1($2):
	${0:pass}
endsnippet

snippet defs "instance method" b
def $1(self`!p
add_str_if(snip, t[2], ", ")
refresh(snip)
`$2):
	${0:pass}
endsnippet

snippet defc "class method" b
def $1(cls`!p
add_str_if(snip, t[2], ", ")
refresh(snip)
`$2):
	${0:pass}
endsnippet

snippet defm "metaclass method" b
def $1(meta`!p
add_str_if(snip, t[2], ", ")
refresh(snip)
`$2):
	${0:pass}
endsnippet

snippet cls "class definition" b
class $1`!p
add_str_if(snip, t[2], "(")
`$2`!p
add_str_if(snip, t[2], ")")
`:
	${0:pass}
endsnippet

snippet cls2 "class definition py2 version" b
class $1(${2:object}):
	${0:pass}
endsnippet

snippet __init "__init__ method" b
def __init__(self`!p
add_str_if(snip, t[2], ", ")
refresh(snip)
`$2):
	${0:pass}
endsnippet

snippet __call "__call__ method" b
def __call__(self`!p
add_str_if(snip, t[2], ", ")
refresh(snip)
`$2):
	${0:pass}
endsnippet

snippet __repr "__repr__ method" b
def __repr__(self):
	${0:pass}
endsnippet

snippet __str "__str__ method" b
def __str__(self):
	${0:pass}
endsnippet

snippet __del "__del__ method" b
def __del__(self):
	${0:pass}
endsnippet

snippet __getattr "__getattr__ method" b
def __getattr__(self, name):
	${0:pass}
endsnippet

# descriptor methods
snippet __get "__get__ method" b
def __get__(self, instance, owner):
	${0:pass}
endsnippet

snippet __set "__set__ method" b
def __set__(self, instance, value):
	${0:pass}
endsnippet

snippet __delete "__delete__ method" b
def __delete__(self, instance):
	${0:pass}
endsnippet

snippet fixture "pytest fixture decorator" b
@pytest.fixture($1)
endsnippet

snippet add_argument "add argument to parser" b
parser.add_argument($1)
endsnippet

snippet license-agpl "AGPL license statement" b
# Copyright (C) `!p
import datetime
snip.rv += str(datetime.date.today().year)
` Zhao Jiarong <kawing.chiu.sysu at gmail dot com>
#
# This file is part of $1.
# 
# $1 is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
# 
# $1 is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with $1. If not, see <http://www.gnu.org/licenses/>.
endsnippet

#########
# some functions, still testing

#snippet add_args "add arguments to parser" b
#def add_arguments(parser):
#	${1:arg_add}$2
#
#$0
#endsnippet
#
#snippet parse_args "arg parse function" b
#def _parse_args():
#	parser = ArgumentParser(description="$1")`!p
#indent = get_indent(snip, 1)
#add_str_if_not_beginswith(snip, t[2], "\n", "\n" + indent)`$2
#	${3:#}add_arguments(parser)
#	args = parser.parse_args()
#	return args
#
#args = _parse_args()
#
#$0
#endsnippet

#snippet arg_add "add an argument" b
#parser.add_argument("$1",`!p
#add_str_if_not_beginswith(snip, t[2], " ", " \"")
#`$2`!p
#indent = get_indent(snip, 2)
#add_str_if_not_beginswith(snip, t[2], " ", "\",")
#add_str(snip, "\n" + indent)
#`help="$3"`!p
#add_str_if(snip, t[4], ",\n" + indent)
#`$4)
#endsnippet

#snippet create_dir "directory creation func" b
#def _create_dir(*paths):
#	for path in paths:
#		try:
#			os.makedirs(path)
#		except OSError as e:
#			if not os.path.isdir(path):
#				log.error("Directory '{}' cannot be created.".format(path))
#				raise
#
#$0
#endsnippet

#snippet init_log "logging initialization" b
#_default_log_path = ${1:"log/"}
#
#def _init_log(log_path):
#	log = logging.getLogger(__name__)
#	log.setLevel(logging.DEBUG)
#
#	ch = logging.StreamHandler()
#	ch.setFormatter(logging.Formatter("%(levelname)s: %(message)s"))
#	log.addHandler(ch)
#
#	log_path_ready = True
#	try:
#		os.makedirs(os.path.abspath(log_path))
#	except OSError as e:
#		if not os.path.isdir(log_path):
#			log_path_ready = False
#	log_file = os.path.splitext(os.path.basename(__file__))[0] + ".py.log"
#	log_file = os.path.join(log_path, log_file)
#
#	if log_path_ready:
#		fh = logging.handlers.RotatingFileHandler(log_file, maxBytes=5 * 1024 * 1024,
#				backupCount=3, delay=True)
#		fh.setFormatter(logging.Formatter("%(asctime)s %(process)d - %(levelname)s - "
#				"%(name)s - %(message)s"))
#		log.addHandler(fh)
#	else:
#		log.warning("Log path '{}' not usable, "
#				"logging to file is disabled.".format(log_path))
#
#	return log, ch
#
#log, console_handler = _init_log(_default_log_path)
#
#
#$0
#endsnippet

####
# almost works
# testing
#snippet test "function definition" b
#def $1($2):`!p
#indent = get_indent(snip)
#prefix = '\n' + indent + '"""'
#add_str_if_not_beginswith(snip, t[3], "\n", prefix)
#`$3`!p
#if '\n' not in t[3]:
#    suffix = '"""' 
#else:
#    suffix = prefix
##refresh(snip)
#if t[3]: #and is_ascii(t[3][0:1]):
#    add_str_if_not_beginswith(snip, t[3], "\n", suffix)
#`
#	${0:pass}
#endsnippet
###
