extends c
priority 1

global !p
from ultisnips_helpers import *
endglobal

snippet iostream "#include <iostream>" b
#include <iostream>
endsnippet

snippet sstream "#include <sstream>" b
#include <sstream>
endsnippet

snippet fstream "#include <fstream>" b
#include <fstream>
endsnippet

snippet thread "#include <thread>" b
#include <thread>
endsnippet

snippet atomic "#include <atomic>" b
#include <atomic>
endsnippet

snippet array "#include <array>" b
#include <array>
endsnippet

snippet mutex "#include <mutex>" b
#include <mutex>
endsnippet

snippet memory "#include <memory>" b
#include <memory>
endsnippet

snippet utility "#include <utility>" b
#include <utility>
endsnippet

snippet exception "#include <exception>" b
#include <exception>
endsnippet

snippet functional "#include <functional>" b
#include <functional>
endsnippet

snippet algorithm "#include <algorithm>" b
#include <algorithm>
endsnippet

snippet tuple "#include <tuple>" b
#include <tuple>
endsnippet

snippet map "#include <map>" b
#include <map>
endsnippet

snippet new "#include <new>" b
#include <new>
endsnippet

snippet vector "#include <vector>" b
#include <vector>
endsnippet

snippet string "#include <string>" b
#include <string>
endsnippet

snippet numeric "#include <numeric>" b
#include <numeric>
endsnippet

snippet condition_variable "#include <condition_variable>" b
#include <condition_variable>
endsnippet

snippet chrono "#include <chrono>" b
#include <chrono>
endsnippet

snippet ustd "using namespace std" b
using namespace std;
endsnippet

snippet size_t "size_t" w
size_t $0
endsnippet

snippet size_of_array "size_of_array function" b
template<typename T, size_t N>
constexpr size_t size_of_array(T (&)[N]) {
	return N;
}
endsnippet

snippet for "for loop" b
for ($1) {
	${0:;}
}
endsnippet

snippet cls "class definition" b
class $1`!p
add_str_if(snip, t[2], " : ")
refresh(snip)
`$2
{
public:
	$1($3);
	$4~$1();$0

private:

};
endsnippet

# no need to define defs, just use def
#snippet defs "member function definition" b
#$1`!p
#add_str_if(snip, t[1], " ")
#refresh(snip)
#`$2`!p
#add_str_if(snip, t[2], "::")
#refresh(snip)
#`$3($4)
#{
#	${0:;}
#}
#endsnippet

snippet cto "constructor" w
$1($2);
endsnippet

snippet dto "destructor" w
~$1();
endsnippet

snippet ctor "constructor definition" w
$1`!p
add_str_if(snip, t[1], "::")
refresh(snip)
`$2::$2($3)`!p
indent = get_indent(snip, shift=1)
prefix = ' :\n' + indent
add_str_if(snip, t[4], prefix)
`$4
{
	${0:;}
}
endsnippet

snippet dtor "destructor definition" b
$1`!p
add_str_if(snip, t[1], "::")
refresh(snip)
`$2::~$2()
{
	${0:;}
}
endsnippet

snippet u "using namespace" b
using namespace $1;
endsnippet

snippet c "const" w
const $0
endsnippet

snippet v "virtual" w
virtual $0
endsnippet

snippet s "std::" w
std::
endsnippet

snippet tpl "template definition" w
template<$1>$0
endsnippet

snippet ns "namespace definition" b
namespace`!p
add_str_if(snip, t[1], " ")
refresh(snip)
`$1 {
	$0

} // namespace $1
endsnippet

snippet up "unique_ptr" w
std::unique_ptr<$1>
endsnippet

snippet dynamic_cast "dynamic_cast" w
dynamic_cast<$1>($2)
endsnippet

snippet override "override" w
override $0
endsnippet

snippet << "cout << ... << endl;" b
cout << "$1"`!p
add_str_if(snip, t[2], " << ")
refresh(snip)
`$2 << endl;
endsnippet




